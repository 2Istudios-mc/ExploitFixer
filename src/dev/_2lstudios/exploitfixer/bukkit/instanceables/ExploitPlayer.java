package dev._2lstudios.exploitfixer.bukkit.instanceables;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.URLConnection;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;

import org.bukkit.Server;
import org.bukkit.entity.Player;
import org.bukkit.event.Cancellable;
import org.bukkit.plugin.Plugin;

import dev._2lstudios.exploitfixer.bukkit.managers.ExploitPlayerManager;
import dev._2lstudios.exploitfixer.bukkit.managers.ModuleManager;
import dev._2lstudios.exploitfixer.bukkit.modules.MessagesModule;
import dev._2lstudios.exploitfixer.bukkit.modules.NotificationsModule;
import dev._2lstudios.exploitfixer.bukkit.utils.VersionUtil;
import dev._2lstudios.exploitfixer.shared.interfaces.ViolationModule;
import dev._2lstudios.hamsterapi.enums.PacketType;
import dev._2lstudios.hamsterapi.hamsterplayer.HamsterPlayer;
import dev._2lstudios.hamsterapi.wrappers.PacketWrapper;

public class ExploitPlayer {
	private final ExploitPlayerManager exploitPlayerManager;
	private final MessagesModule messagesModule;
	private final NotificationsModule notificationsModule;
	private final Map<ViolationModule, Double> violations;
	private final Collection<Collection<String>> punishments;
	private final String name;
	private String onlineUUID;
	private double lastViolation;
	private int channels;
	private boolean logged;

	public ExploitPlayer(final Plugin plugin, final String name, final ModuleManager moduleManager) {
		this.exploitPlayerManager = moduleManager.getExploitPlayerManager();
		this.messagesModule = moduleManager.getMessagesModule();
		this.notificationsModule = moduleManager.getNotificationsModule();
		this.violations = new HashMap<>();
		this.punishments = new HashSet<>();
		this.name = name;
		this.onlineUUID = null;
		this.lastViolation = 0;
		this.channels = 0;
		this.logged = false;
	}

	public int getChannels() {
		return channels;
	}

	public int addChannels(final int channels) {
		return this.channels += channels;
	}

	public double getViolations(final ViolationModule module) {
		return this.violations.getOrDefault(module, 0D);
	}

	public String getOnlineUUID() {
		if (onlineUUID == null) {
			try {
				final URLConnection connection = new URL("https://api.mojang.com/users/profiles/minecraft/" + name)
						.openConnection();

				connection.setDoOutput(true);
				connection.connect();

				final BufferedReader bufferedReader = new BufferedReader(
						new InputStreamReader(connection.getInputStream()));
				final StringBuilder response = new StringBuilder();

				String inputLine;

				while ((inputLine = bufferedReader.readLine()) != null)
					response.append(inputLine).append("\n");

				bufferedReader.close();
				onlineUUID = response.toString();
			} catch (final Exception ignored) {
			}
		}

		return onlineUUID;
	}

	public void addVls(final Plugin plugin, final Cancellable event, final HamsterPlayer hamsterPlayer,
			final ViolationModule module, final double amount) {
		addVls(plugin, event, null, hamsterPlayer, module, amount);
	}

	public void addVls(final Plugin plugin, final Cancellable event, final PacketWrapper packet,
			final HamsterPlayer hamsterPlayer, final ViolationModule module, final double amount) {
		final Player player = hamsterPlayer.getPlayer();
		final Violations violations = (Violations) module.getViolations();

		if (violations != null) {
			final Server server = plugin.getServer();
			final double currentTime = System.currentTimeMillis();

			if (currentTime - lastViolation >= 1000) {
				lastViolation = currentTime;

				for (final ViolationModule violationModule : new HashSet<>(this.violations.keySet())) {
					final double vls = this.violations.get(violationModule) - violationModule.getReduceVls();

					if (vls <= 0) {
						this.violations.remove(violationModule);
					} else {
						this.violations.put(violationModule, vls);
					}
				}
			}

			final double newVls = getViolations(module) + amount;

			this.violations.put(module, newVls);

			if (event instanceof Cancellable && module.getCancelVls() <= newVls) {
				((Cancellable) event).setCancelled(true);
			}

			for (final int threshold : violations.getViolations()) {
				if (threshold <= newVls) {
					final Collection<String> commands = violations.getCommands(threshold);

					if (commands != null && !commands.isEmpty() && !punishments.contains(commands)) {
						for (final String punishCommand : commands) {
							if (punishCommand.equals("kick")) {
								final String locale = VersionUtil.getLocale(player);
								final String kickMessage = messagesModule.getKickMessage(module, locale);

								hamsterPlayer.disconnect(kickMessage);
								hamsterPlayer.closeChannel();
								exploitPlayerManager.addPunishment();
							} else if (punishCommand.equals("notification")) {
								final String moduleName = module.getName();

								if (packet != null) {
									final PacketType packetType = packet.getType();
									final String name;

									if (packetType != null) {
										name = packetType.toString();
									} else {
										name = moduleName;
									}

									notificationsModule.sendNotification(name, player, (int) newVls);
								} else {
									notificationsModule.sendNotification(moduleName, player, (int) newVls);
								}
							} else {
								server.getScheduler().runTask(plugin, () -> {
									server.dispatchCommand(server.getConsoleSender(),
											punishCommand.replace("%player%", player.getName()));
								});
							}
						}

						punishments.add(commands);
					}
				}
			}
		}
	}

	public void clear() {
		this.violations.clear();
		this.punishments.clear();
		this.lastViolation = 0;
		this.channels = 0;
	}

	public void setLogged(final boolean logged) {
		this.logged = logged;
	}

	public boolean isLogged() {
		return logged;
	}

	public Collection<Collection<String>> getPunishments() {
		return this.punishments;
	}
}
