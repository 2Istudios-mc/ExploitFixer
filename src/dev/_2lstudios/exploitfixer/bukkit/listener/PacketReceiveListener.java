package dev._2lstudios.exploitfixer.bukkit.listener;

import java.nio.charset.StandardCharsets;
import java.util.Collection;
import java.util.Map;

import org.bukkit.GameMode;
import org.bukkit.Material;
import org.bukkit.block.BlockState;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.inventory.InventoryType;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.InventoryHolder;
import org.bukkit.inventory.InventoryView;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.PlayerInventory;
import org.bukkit.inventory.meta.BlockStateMeta;
import org.bukkit.inventory.meta.BookMeta;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.plugin.Plugin;

import dev._2lstudios.exploitfixer.bukkit.instanceables.ExploitPlayer;
import dev._2lstudios.exploitfixer.bukkit.managers.ExploitPlayerManager;
import dev._2lstudios.exploitfixer.bukkit.managers.ModuleManager;
import dev._2lstudios.exploitfixer.bukkit.modules.CustomPayloadModule;
import dev._2lstudios.exploitfixer.bukkit.modules.ItemsFixModule;
import dev._2lstudios.exploitfixer.bukkit.modules.NotificationsModule;
import dev._2lstudios.exploitfixer.bukkit.modules.PacketsModule;
import dev._2lstudios.hamsterapi.enums.PacketType;
import dev._2lstudios.hamsterapi.events.PacketReceiveEvent;
import dev._2lstudios.hamsterapi.hamsterplayer.HamsterPlayer;
import dev._2lstudios.hamsterapi.wrappers.PacketWrapper;

public class PacketReceiveListener implements Listener {
    private final Plugin plugin;
    private final CustomPayloadModule customPayloadModule;
    private final ExploitPlayerManager exploitPlayerManager;
    private final ItemsFixModule itemsFixModule;
    private final NotificationsModule notificationsModule;
    private final PacketsModule packetsModule;

    PacketReceiveListener(final Plugin plugin, final ModuleManager moduleManager) {
        this.plugin = plugin;
        this.customPayloadModule = moduleManager.getCustomPayloadModule();
        this.exploitPlayerManager = moduleManager.getExploitPlayerManager();
        this.itemsFixModule = moduleManager.getItemsFixModule();
        this.notificationsModule = moduleManager.getNotificationsModule();
        this.packetsModule = moduleManager.getPacketsModule();
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.LOWEST)
    public void onPacketReceive(final PacketReceiveEvent event) {
        final HamsterPlayer hamsterPlayer = event.getHamsterPlayer();
        final Player player = hamsterPlayer.getPlayer();
        final PacketWrapper packetWrapper = event.getPacket();
        final PacketType packetType = packetWrapper.getType();

        if (packetType != PacketType.PacketPlayInKeepAlive) {
            final Map<String, String> strings = packetWrapper.getStrings();
            final ExploitPlayer exploitPlayer = exploitPlayerManager.get(player);
            final String playerName = player.getName(), packetName = packetWrapper.getName();
            final double dataVls = packetsModule.getDataVls();
            final int dataBytes = packetsModule.getDataBytes();

            if (packetsModule.isEnabled()) {
                final Map<String, Integer> integers = packetWrapper.getIntegers();
                final InventoryView inventoryView = player.getOpenInventory();
                final double windowClick = packetsModule.getWindowClick(),
                        setCreativeSlot = packetsModule.getSetCreativeSlot();
                final int dataBytesSigns = packetsModule.getDataBytesSign();

                if (integers.containsKey("slot")) {
                    final Inventory topInventory = inventoryView.getTopInventory(),
                            bottomInventory = inventoryView.getBottomInventory();
                    final int slot = integers.get("slot"), maxSlots;

                    if (bottomInventory.getType() == InventoryType.PLAYER
                            && topInventory.getType() == InventoryType.CRAFTING) {
                        maxSlots = inventoryView.countSlots() + 4;
                    } else {
                        maxSlots = inventoryView.countSlots();
                    }

                    if (slot < 0 && slot != -999 && slot != -1) {
                        notificationsModule.debug("[" + packetName + "|WindowClick] " + playerName
                                + " sent a slot less than 0 and not [-999 or -1]! Slot: " + slot + " Added vls: "
                                + windowClick);

                        event.setCancelled(true);
                        exploitPlayer.addVls(plugin, event, hamsterPlayer, packetsModule, windowClick);
                        return;
                    } else if (slot >= maxSlots) {
                        notificationsModule.debug(
                                "[" + packetName + "|WindowClick] " + playerName + " exceeded max available slots! ("
                                        + slot + "/" + maxSlots + ") Added vls: " + windowClick);

                        event.setCancelled(true);
                        exploitPlayer.addVls(plugin, event, hamsterPlayer, packetsModule, windowClick);
                        return;
                    }
                }

                if (setCreativeSlot > 0 && packetType == PacketType.PacketPlayInSetCreativeSlot) {
                    if (player.getGameMode() != GameMode.CREATIVE) {
                        notificationsModule.debug("[" + packetName + "|SetCreativeSlot] " + playerName
                                + " sent SET_CREATIVE_SLOT without CREATIVE! Added vls: " + setCreativeSlot);

                        event.setCancelled(true);
                        exploitPlayer.addVls(plugin, event, hamsterPlayer, packetsModule, setCreativeSlot);
                        return;
                    }
                }

                int packetSize = 0;

                if (dataVls > 0) {
                    final Map<String, Object> objects = packetWrapper.getObjects();

                    if (!objects.isEmpty()) {
                        final Collection<Object> objectsValues = objects.values();

                        for (final Object object : objectsValues) {
                            if (object instanceof ItemStack) {
                                packetSize += getItemLength((ItemStack) object, exploitPlayer, hamsterPlayer,
                                        packetName, dataBytes);
                            } else {
                                packetSize += String.valueOf(object).getBytes(StandardCharsets.UTF_8).length;
                            }
                        }
                    }

                    if (dataBytes > 0 && packetSize > dataBytes) {
                        notificationsModule.debug("[" + packetName + "|Data] " + playerName + " sent a packet of "
                                + packetSize + " bytes long!");

                        event.setCancelled(true);
                        exploitPlayer.addVls(plugin, event, hamsterPlayer, packetsModule, dataVls);
                        return;
                    }

                    if (dataBytesSigns > 0 && packetType == PacketType.PacketPlayInUpdateSign
                            && checkSign(strings.values().toArray(new String[0]))) {
                        notificationsModule.debug("[" + packetName + "|Data] " + playerName
                                + " has sent a too big sign packet! Added vls: " + dataVls);

                        event.setCancelled(true);
                        exploitPlayer.addVls(plugin, event, hamsterPlayer, packetsModule, dataVls);
                        return;
                    }
                }

                final double bytesDividerAddition = packetSize / packetsModule.getDataBytesDivider();

                exploitPlayer.addVls(plugin, event, hamsterPlayer, packetsModule,
                        packetsModule.getMultiplier(packetName) + bytesDividerAddition);
            }

            if (customPayloadModule.isEnabled() && packetType == PacketType.PacketPlayInCustomPayload) {
                if (!strings.isEmpty()) {
                    final String tag = strings.values().iterator().next();
                    final double tagVls = customPayloadModule.getTagVls(), bookVls = customPayloadModule.getBookVls();

                    if (tagVls > 0 && tag == null || tag.isEmpty()) {
                        notificationsModule.debug("[" + packetName + "|Tag] " + playerName
                                + " sent CUSTOM_PAYLOAD without TAG! Added vls: " + tagVls);

                        event.setCancelled(true);
                        exploitPlayer.addVls(plugin, event, hamsterPlayer, customPayloadModule, tagVls);
                        return;
                    } else {
                        if (tag.equals("MC|BEdit") || tag.equals("MC|BSign") || tag.equals("MC|BOpen")) {
                            final PlayerInventory playerInventory = player.getInventory();
                            final ItemStack itemInHand = playerInventory.getItem(playerInventory.getHeldItemSlot());

                            if (itemInHand != null && !itemInHand.getType().toString().contains("BOOK")) {
                                notificationsModule.debug("[" + packetName + "|Book] " + playerName
                                        + " tried to send a " + tag + " custompayload packet without a book in hand!");

                                event.setCancelled(true);
                                exploitPlayer.addVls(plugin, event, hamsterPlayer, customPayloadModule, bookVls);
                                return;
                            } /*
                               * else if (byteLength > customPayloadModule.getBookBytes()) {
                               * notificationsModule.debug(playerName + " tried to send a " + tag +
                               * " custompayload packet without a book in hand!"); event.setCancelled(true);
                               * exploitPlayer.addVls(plugin, event, player, customPayloadModule,
                               * customPayloadModule.getBookVls()); return; } // WORK IN PROGRESS
                               */
                        }

                        exploitPlayer.addVls(plugin, event, hamsterPlayer, customPayloadModule,
                                customPayloadModule.getMultiplier(tag));
                    }
                } else {
                    notificationsModule
                            .debug("[" + packetName + "] " + playerName + " sent a empty CustomPayload packet!");

                    event.setCancelled(true);
                }
            }
        }

        final Map<String, ItemStack> items = packetWrapper.getItems();

        if (itemsFixModule.isEnabled() && items.containsKey("b")) {
            final ItemStack itemStack = items.get("b");

            if (itemStack != null) {
                final String materialName = itemStack.getType().toString();
                String blocked = null;

                for (final String blockedMaterial : itemsFixModule.getBlacklist()) {
                    if (materialName.equals(blockedMaterial)) {
                        itemStack.setType(Material.AIR);
                        itemStack.setItemMeta(null);
                        blocked = materialName;
                        break;
                    }
                }

                final ItemStack fixedItemStack = itemsFixModule.fixItem(itemStack);

                packetWrapper.write("b", fixedItemStack);

                if (player != null) {
                    if (blocked != null) {
                        notificationsModule.debug(
                                player.getName() + " had a creative item blocked by ExploiFixer! (" + blocked + ")");
                    } else {
                        notificationsModule.debug(player.getName() + " had a creative item fixed by ExploiFixer!");
                    }
                }
            }
        }
    }

    private int getItemLength(final ItemStack itemStack, final ExploitPlayer exploitPlayer,
            final HamsterPlayer hamsterPlayer, final String packetName, final int itemBytesMax) {
        int itemBytesLength = 0;

        if (itemStack != null) {
            final ItemMeta itemMeta = itemStack.getItemMeta();

            try {
                itemBytesLength += itemStack.getData().toString().getBytes(StandardCharsets.UTF_8).length;
            } catch (final Exception exception) {
                notificationsModule
                        .debug("[" + packetName + "] There was an exception when processing itemStack data to String!");
            }

            if (itemStack.hasItemMeta() && itemMeta != null) {
                try {
                    if (itemMeta instanceof BlockStateMeta) {
                        final BlockStateMeta blockStateMeta = (BlockStateMeta) itemMeta;

                        if (blockStateMeta.hasBlockState()) {
                            final BlockState blockState = blockStateMeta.getBlockState();

                            if (blockState instanceof InventoryHolder) {
                                final InventoryHolder inventoryHolder = (InventoryHolder) blockState;

                                for (final ItemStack itemStack1 : inventoryHolder.getInventory().getContents()) {
                                    itemBytesLength += getItemLength(itemStack1, exploitPlayer, hamsterPlayer,
                                            packetName, itemBytesMax);

                                    if (itemBytesLength > itemBytesMax) {
                                        return itemBytesLength;
                                    }
                                }
                            }
                        }
                    } else {
                        throw new Exception();
                    }
                } catch (final Exception exception) {
                    if (itemMeta instanceof BookMeta) {
                        itemBytesLength += getBookLength(exploitPlayer, hamsterPlayer, itemMeta, packetName);
                    } else {
                        try {
                            itemBytesLength += itemMeta.toString().getBytes(StandardCharsets.UTF_8).length;
                        } catch (final NullPointerException e) {
                            itemBytesLength += (itemMeta.getClass().getName() + "@"
                                    + Integer.toHexString(itemMeta.hashCode())).getBytes(StandardCharsets.UTF_8).length;
                        }
                    }
                }
            }
        }

        return itemBytesLength;
    }

    private int getBookLength(final ExploitPlayer exploitPlayer, final HamsterPlayer hamsterPlayer,
            final ItemMeta itemMeta, final String packetName) {
        final Player player = hamsterPlayer.getPlayer();
        final BookMeta bookMeta = (BookMeta) itemMeta;
        final double dataVls = packetsModule.getDataVls();
        final int pageCount = bookMeta.getPageCount(), dataBytesBook = packetsModule.getDataBytesBook();
        int bookTotalBytes = 0;

        if (pageCount > 50) {
            notificationsModule.debug("[" + packetName + "|Book] " + player.getName()
                    + " has sent a packet with a book with too many pages! (" + pageCount + "/" + 50 + ") Added vls: "
                    + dataVls);

            exploitPlayer.addVls(plugin, null, hamsterPlayer, packetsModule, dataVls);
        } else {
            for (final String page : bookMeta.getPages()) {
                final int pageBytes = page.getBytes(StandardCharsets.UTF_8).length;

                bookTotalBytes += pageBytes;

                if (pageBytes > dataBytesBook) {
                    notificationsModule.debug("[" + packetName + "|Book] " + player.getName()
                            + " has sent a packet with a book with too many characters per page! (" + pageBytes + "/"
                            + dataBytesBook + ") Added vls: " + dataVls);

                    exploitPlayer.addVls(plugin, null, hamsterPlayer, packetsModule, dataVls);
                    break;
                }
            }

            return bookTotalBytes;
        }

        return itemMeta.toString().getBytes(StandardCharsets.UTF_8).length;
    }

    private boolean checkSign(final String[] linesString) {
        final int dataBytesSign = packetsModule.getDataBytesSign();

        if (linesString != null) {
            if (linesString.length > 4) {
                return true;
            } else {
                for (final String line : linesString) {
                    if (line.getBytes(StandardCharsets.UTF_8).length > dataBytesSign) {
                        return true;
                    }
                }
            }
        }

        return false;
    }
}