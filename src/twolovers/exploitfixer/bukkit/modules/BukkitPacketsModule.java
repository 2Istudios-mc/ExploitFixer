package twolovers.exploitfixer.bukkit.modules;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.events.PacketContainer;
import com.comphenix.protocol.events.PacketEvent;
import com.comphenix.protocol.reflect.StructureModifier;
import com.comphenix.protocol.utility.StreamSerializer;
import com.comphenix.protocol.wrappers.WrappedBlockData;
import com.comphenix.protocol.wrappers.WrappedChatComponent;
import com.comphenix.protocol.wrappers.nbt.NbtBase;
import io.netty.buffer.ByteBuf;

import org.bukkit.block.BlockState;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.event.Cancellable;
import org.bukkit.inventory.InventoryHolder;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.BlockStateMeta;
import org.bukkit.inventory.meta.BookMeta;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.plugin.Plugin;
import twolovers.exploitfixer.bukkit.instanceables.BukkitViolations;
import twolovers.exploitfixer.bukkit.utils.VersionUtil;
import twolovers.exploitfixer.interfaces.instanceables.ExploitPlayer;
import twolovers.exploitfixer.interfaces.instanceables.Violations;
import twolovers.exploitfixer.interfaces.managers.ModuleManager;
import twolovers.exploitfixer.interfaces.modules.PacketsModule;

import java.io.ByteArrayInputStream;
import java.io.DataInputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicInteger;

public class BukkitPacketsModule implements PacketsModule {
	private final Plugin plugin;
	private final ModuleManager moduleManager;
	private final Map<String, Double> multipliers = new HashMap<>();
	private Violations violations;
	private double bigDataVls, bigDataMaxBytes, blockDig, blockPlace, setCreativeSlot, windowClick, cancelVls,
			reduceVls;
	private int booksMaxBytes, signsMaxBytes;
	private boolean enabled, offline;

	public BukkitPacketsModule(final Plugin plugin, final ModuleManager moduleManager, final Object configYml) {
		this.plugin = plugin;
		this.moduleManager = moduleManager;
		reload(configYml);
	}

	@Override
	final public void reload(final Object configYml) {
		final YamlConfiguration configYml1 = (YamlConfiguration) configYml;
		final ConfigurationSection configurationSection = configYml1.getConfigurationSection("packets.multipliers");
		final String name = getName().toLowerCase();

		this.enabled = configYml1.getBoolean(name + ".enabled");
		this.cancelVls = configYml1.getDouble(name + ".cancel_vls");
		this.reduceVls = configYml1.getDouble(name + ".reduce_vls");
		this.offline = configYml1.getBoolean(name + ".invalid.offline");
		this.bigDataVls = configYml1.getDouble(name + ".invalid.big_data.vls");
		this.bigDataMaxBytes = configYml1.getDouble(name + ".invalid.big_data.max_bytes", 24000);
		this.booksMaxBytes = configYml1.getInt(name + ".invalid.big_data.max_bytes_book", 268);
		this.signsMaxBytes = configYml1.getInt(name + ".invalid.big_data.max_bytes_sign", 47);
		this.windowClick = configYml1.getDouble(name + ".invalid.window_click");
		this.blockPlace = configYml1.getDouble(name + ".invalid.block_place");
		this.blockDig = configYml1.getDouble(name + ".invalid.block_dig");
		this.setCreativeSlot = configYml1.getDouble(name + ".invalid.set_creative_slot");
		this.violations = new BukkitViolations(configYml1.getConfigurationSection(name + ".violations"));

		for (final String key : configurationSection.getKeys(false))
			multipliers.put(key, configurationSection.getDouble(key));
	}

	@Override
	public double getMultiplier(final String packetName) {
		return multipliers.getOrDefault(packetName, 1D);
	}

	@Override
	public boolean isEnabled() {
		return enabled;
	}

	@Override
	public void check(final Object eventObject) {
		if (eventObject instanceof PacketEvent) {
			final PacketEvent event = (PacketEvent) eventObject;

			if (!event.isCancelled()) {
				final Player player = event.getPlayer();
				final PacketType packetType = event.getPacketType();

				if (player != null && player.isOnline()) {
					try {
						final UUID uuid = player.getUniqueId();
						final ExploitPlayer exploitPlayer = moduleManager.getExploitPlayerManager().get(uuid, player);
						final PacketContainer packet = event.getPacket();
						final StructureModifier<WrappedChatComponent[]> chatComponentArrays;
						final StructureModifier<String[]> stringArrays = packet.getStringArrays();
						final WrappedChatComponent[] chatComponentArrays0;

						if (!VersionUtil.isOneDotSeven()) {
							chatComponentArrays = packet.getChatComponentArrays();
							chatComponentArrays0 = chatComponentArrays.readSafely(0);
						} else {
							chatComponentArrays = null;
							chatComponentArrays0 = null;
						}

						if (bigDataVls > 0 && packet.getType() == PacketType.Play.Client.UPDATE_SIGN
								&& checkSign(chatComponentArrays0, stringArrays.readSafely(0))) {
							exploitPlayer.addVls(plugin, event, player, this, bigDataVls);
						}

						if (!event.isCancelled() && bigDataVls > 0) {
							final StructureModifier<ItemStack> itemModifier = packet.getItemModifier();
							final StructureModifier<ItemStack[]> itemArrayModifier = packet.getItemArrayModifier();
							final StructureModifier<String> strings = packet.getStrings();
							final StructureModifier<NbtBase<?>> nbtModifier = packet.getNbtModifier();
							final AtomicInteger packetSize = new AtomicInteger(0);

							if (!VersionUtil.isOneDotSeven()) {
								for (final WrappedBlockData wrappedBlockData : packet.getBlockData().getValues()) {
									if (wrappedBlockData != null) {
										final int dataBytes = wrappedBlockData.toString()
												.getBytes(StandardCharsets.UTF_8).length;

										packetSize.addAndGet(dataBytes);
									}
								}

								for (final List<ItemStack> itemList : packet.getItemListModifier().getValues()) {
									for (final ItemStack itemStack : itemList) {
										checkItem(itemStack, event, exploitPlayer, player, packetSize);
									}
								}
							}

							for (final ItemStack itemStack : itemModifier.getValues()) {
								checkItem(itemStack, event, exploitPlayer, player, packetSize);
							}

							for (final ItemStack[] itemList : itemArrayModifier.getValues())
								for (final ItemStack itemStack : itemList) {
									checkItem(itemStack, event, exploitPlayer, player, packetSize);
								}

							for (final String string : strings.getValues()) {
								if (string != null) {
									final int dataBytes = string.getBytes(StandardCharsets.UTF_8).length;

									packetSize.addAndGet(dataBytes);
								}
							}

							for (final NbtBase<?> nbtBase : nbtModifier.getValues()) {
								if (nbtBase != null) {
									final int dataBytes = nbtBase.getValue().toString()
											.getBytes(StandardCharsets.UTF_8).length;

									packetSize.addAndGet(dataBytes);
								}
							}

							if (!VersionUtil.isOneDotSeven()) {
								final StructureModifier<ByteBuf> byteBufModifier = packet
										.getSpecificModifier(ByteBuf.class);

								for (final ByteBuf byteBuf : byteBufModifier.getValues()) {
									try {
										if (byteBuf != null) {
											final byte[] bytes = new byte[byteBuf.readableBytes()];
											byteBuf.readBytes(bytes);
											final DataInputStream inputStream = new DataInputStream(
													new ByteArrayInputStream(bytes));

											checkItem(StreamSerializer.getDefault().deserializeItemStack(inputStream),
													event, exploitPlayer, player, packetSize);

											inputStream.close();
											packetSize.addAndGet(((ByteBuf) byteBuf).capacity());
										}
									} catch (final IOException ignored) {
									}
								}

								if (packetSize.get() > bigDataMaxBytes) {
									exploitPlayer.addVls(plugin, event, player, this, bigDataVls);
								}
							}

							if (!event.isCancelled()) {
								exploitPlayer.addVls(plugin, event, player, this, getMultiplier(packetType.name()));
							}
						}
					} catch (final UnsupportedOperationException ignored) {
						event.setCancelled(true);
					}
				} else if (this.offline && packetType != PacketType.Play.Client.CUSTOM_PAYLOAD
						&& packetType != PacketType.Play.Client.SETTINGS) {
					event.setCancelled(true);
				}
			}
		}
	}

	@Override
	public boolean isOffline() {
		return offline;
	}

	@Override
	public double getWindowClick() {
		return windowClick;
	}

	@Override
	public double getSetCreativeSlot() {
		return setCreativeSlot;
	}

	@Override
	public double getBlockDig() {
		return blockDig;
	}

	@Override
	public double getBlockPlace() {
		return blockPlace;
	}

	@Override
	public String getName() {
		return "Packets";
	}

	@Override
	public double getCancelVls() {
		return cancelVls;
	}

	@Override
	public double getReduceVls() {
		return reduceVls;
	}

	@Override
	public Violations getViolations() {
		return violations;
	}

	private boolean checkItem(final ItemStack itemStack, final PacketEvent event, final ExploitPlayer exploitPlayer,
			final Player player, final AtomicInteger packetSize) {
		if (itemStack != null && !event.isCancelled()) {
			try {
				final ItemMeta itemMeta = itemStack.getItemMeta();
				int dataBytes = itemStack.getData().toString().getBytes(StandardCharsets.UTF_8).length;

				if (itemMeta != null) {
					try {
						dataBytes += itemMeta.toString().getBytes(StandardCharsets.UTF_8).length;
					} catch (final NullPointerException e) {
						dataBytes += (itemMeta.getClass().getName() + "@" + Integer.toHexString(itemMeta.hashCode()))
								.getBytes(StandardCharsets.UTF_8).length;
					}

					if (!VersionUtil.isOneDotSeven() && itemMeta instanceof BlockStateMeta) {
						final BlockStateMeta blockStateMeta = (BlockStateMeta) itemMeta;

						if (blockStateMeta.hasBlockState()) {
							final BlockState blockState = blockStateMeta.getBlockState();

							if (blockState instanceof InventoryHolder) {
								final InventoryHolder inventoryHolder = (InventoryHolder) blockState;

								for (final ItemStack itemStack1 : inventoryHolder.getInventory().getContents())
									checkItem(itemStack1, event, exploitPlayer, player, packetSize);
							}
						}
					} else if (itemMeta instanceof BookMeta) {
						checkBook(event, exploitPlayer, player, itemMeta);
					}
				}

				packetSize.addAndGet(dataBytes);

				return false;
			} catch (final Exception exception) {
				return true;
			}
		} else
			return true;
	}

	private void checkBook(final Cancellable event, final ExploitPlayer exploitPlayer, final Player player,
			final ItemMeta itemMeta) {
		if (bigDataVls > 0 && itemMeta instanceof BookMeta) {
			final BookMeta bookMeta = (BookMeta) itemMeta;

			if (exploitPlayer == null) {
				event.setCancelled(true);
			} else if (bookMeta.getPageCount() > 50) {
				exploitPlayer.addVls(plugin, event, player, this, bigDataVls);
			} else {
				for (final String page : bookMeta.getPages()) {
					if (event.isCancelled()) {
						break;
					} else if (page.getBytes(StandardCharsets.UTF_8).length > booksMaxBytes) {
						exploitPlayer.addVls(plugin, event, player, this, bigDataVls);
					}
				}
			}
		}
	}

	private boolean checkSign(final WrappedChatComponent[] linesChatComponent, final String[] linesString) {
		if (linesChatComponent != null) {
			if (linesChatComponent.length > 4) {
				return true;
			} else
				for (final WrappedChatComponent line : linesChatComponent) {
					if (line.getJson().getBytes(StandardCharsets.UTF_8).length > signsMaxBytes) {
						return true;
					}
				}
		}

		if (linesString != null) {
			if (linesString.length > 4) {
				return true;
			} else
				for (final String line : linesString) {
					if (line.getBytes(StandardCharsets.UTF_8).length > signsMaxBytes) {
						return true;
					}
				}
		}

		return false;
	}
}
