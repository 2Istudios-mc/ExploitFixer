package twolovers.exploitfixer.bukkit.instanceables;

import com.comphenix.protocol.events.PacketEvent;
import org.bukkit.Server;
import org.bukkit.entity.Player;
import org.bukkit.event.Cancellable;
import org.bukkit.plugin.Plugin;
import org.bukkit.scheduler.BukkitScheduler;
import twolovers.exploitfixer.bukkit.nms.CraftPlayerReflector;
import twolovers.exploitfixer.bukkit.utils.VersionUtil;
import twolovers.exploitfixer.interfaces.instanceables.ExploitPlayer;
import twolovers.exploitfixer.interfaces.instanceables.Violations;
import twolovers.exploitfixer.interfaces.managers.ExploitPlayerManager;
import twolovers.exploitfixer.interfaces.managers.ModuleManager;
import twolovers.exploitfixer.interfaces.modules.CancellableModule;
import twolovers.exploitfixer.interfaces.modules.MessagesModule;
import twolovers.exploitfixer.interfaces.modules.Module;
import twolovers.exploitfixer.interfaces.modules.NotificationsModule;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.URLConnection;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;

public class BukkitExploitPlayer implements ExploitPlayer {
	final private ExploitPlayerManager exploitPlayerManager;
	final private MessagesModule messagesModule;
	final private NotificationsModule notificationsModule;
	final private Map<CancellableModule, Double> violations = new HashMap<>();
	final private String name;
	private String onlineUUID = null;
	private boolean logged = false;
	private int channels = 0;
	private double lastViolation = 0;

	public BukkitExploitPlayer(final String name, final ModuleManager moduleManager) {
		this.exploitPlayerManager = moduleManager.getExploitPlayerManager();
		this.messagesModule = moduleManager.getMessagesModule();
		this.notificationsModule = moduleManager.getNotificationsModule();
		this.name = name;
	}

	public int getChannels() {
		return channels;
	}

	public void clearChannels() {
		this.channels = 0;
	}

	@Override
	public int addChannels(final int channels) {
		return this.channels += channels;
	}

	@Override
	public double getViolations(final Module module) {
		if (module instanceof CancellableModule)
			return violations.getOrDefault(module, 0D);
		else
			return 0D;
	}

	@Override
	public String getOnlineUUID() {
		if (onlineUUID == null) {
			try {
				final URLConnection connection = new URL("https://api.mojang.com/users/profiles/minecraft/" + name)
						.openConnection();

				connection.setDoOutput(true);
				connection.connect();

				final BufferedReader bufferedReader = new BufferedReader(
						new InputStreamReader(connection.getInputStream()));
				final StringBuilder response = new StringBuilder();

				String inputLine;

				while ((inputLine = bufferedReader.readLine()) != null)
					response.append(inputLine).append("\n");

				bufferedReader.close();
				onlineUUID = response.toString();
			} catch (final Exception ignored) {
			}
		}

		return onlineUUID;
	}

	@Override
	public void addVls(final Object pluginObject, final Object event, final Object playerObject,
			final CancellableModule module, final double amount) {
		if (playerObject instanceof Player) {
			final Player player = (Player) playerObject;

			if (player.isOnline()) {
				final Violations violations = module.getViolations();

				if (violations != null) {
					final Plugin plugin = (Plugin) pluginObject;
					final Server server = plugin.getServer();
					final double currentTime = System.currentTimeMillis();

					if (currentTime - lastViolation >= 1000) {
						lastViolation = currentTime;

						for (final CancellableModule cancellableModule : new HashSet<>(this.violations.keySet())) {
							final double vls = this.violations.get(cancellableModule)
									- cancellableModule.getReduceVls();

							if (vls <= 0)
								this.violations.remove(cancellableModule);
							else
								this.violations.put(cancellableModule, vls);
						}
					}

					final double oldVls = getViolations(module);
					final double newVls = oldVls + amount;

					this.violations.put(module, newVls);

					if (event instanceof Cancellable && module.getCancelVls() <= newVls) {
						((Cancellable) event).setCancelled(true);
					}

					for (final int threshold : violations.getViolations()) {
						if (threshold > oldVls && threshold <= newVls) {
							final Collection<String> commands = violations.getCommands(threshold);

							if (commands != null && !commands.isEmpty()) {
								for (final String punishCommand : commands)
									if (!punishCommand.isEmpty())
										if (punishCommand.equals("kick")) {
											final CraftPlayerReflector craftPlayer = new CraftPlayerReflector(player);
											final String locale;

											if (VersionUtil.isOneDotFifteen())
												locale = player.getLocale().substring(0, 2);
											else
												locale = player.spigot().getLocale().substring(0, 2);

											final String kickMessage = messagesModule.getKickMessage(module, locale);

											// This is made to sync the current thread with main thread so it doesnt
											// crash.
											if (!server.isPrimaryThread()) {
												final Thread currentThread = Thread.currentThread();

												server.getScheduler().runTask(plugin, () -> {
													craftPlayer.disconnect(kickMessage);
													currentThread.interrupt();
												});

												try {
													Thread.sleep(500L);
												} catch (final InterruptedException e) {
												}
											} else
												craftPlayer.disconnect(kickMessage);

											craftPlayer.closeChannel();
											exploitPlayerManager.addPunishment();
										} else if (punishCommand.equals("notification")) {
											if (event instanceof PacketEvent)
												notificationsModule.sendNotification(
														((PacketEvent) event).getPacketType().name(), player,
														(int) newVls);
											else
												notificationsModule.sendNotification(module.getName(), player,
														(int) newVls);
										} else
											server.getScheduler().runTask(plugin, () -> {
												server.dispatchCommand(server.getConsoleSender(),
														punishCommand.replace("%player%", player.getName()));
											});
							}
						}
					}
				}
			}
		} else if (event instanceof Cancellable)

		{
			((Cancellable) event).setCancelled(true);
		}
	}

	public void clearViolations() {
		violations.clear();
	}

	@Override
	public void setLogged(final boolean logged) {
		this.logged = logged;
	}

	@Override
	public boolean isLogged() {
		return logged;
	}
}
