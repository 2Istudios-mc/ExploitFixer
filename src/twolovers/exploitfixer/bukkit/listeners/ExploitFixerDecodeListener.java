package twolovers.exploitfixer.bukkit.listeners;

import java.nio.charset.StandardCharsets;
import java.util.Collection;
import java.util.Map;
import java.util.logging.Logger;

import org.bukkit.GameMode;
import org.bukkit.block.BlockState;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryType;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.InventoryHolder;
import org.bukkit.inventory.InventoryView;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.PlayerInventory;
import org.bukkit.inventory.meta.BlockStateMeta;
import org.bukkit.inventory.meta.BookMeta;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.plugin.Plugin;

import hamsterapi.enums.PacketType;
import hamsterapi.interfaces.DecodeListener;
import hamsterapi.wrappers.EventWrapper;
import hamsterapi.wrappers.PacketWrapper;
import twolovers.exploitfixer.bukkit.instanceables.ExploitPlayer;
import twolovers.exploitfixer.bukkit.managers.ExploitPlayerManager;
import twolovers.exploitfixer.bukkit.managers.ModuleManager;
import twolovers.exploitfixer.bukkit.modules.CustomPayloadModule;
import twolovers.exploitfixer.bukkit.modules.ItemsFixModule;
import twolovers.exploitfixer.bukkit.modules.NotificationsModule;
import twolovers.exploitfixer.bukkit.modules.PacketsModule;

public class ExploitFixerDecodeListener implements DecodeListener {
    private final Plugin plugin;
    private final CustomPayloadModule customPayloadModule;
    private final ExploitPlayerManager exploitPlayerManager;
    private final NotificationsModule notificationsModule;
    private final PacketsModule packetsModule;
    private final ItemsFixModule itemsFixModule;

    public ExploitFixerDecodeListener(final Plugin plugin, final ModuleManager moduleManager) {
        this.plugin = plugin;
        this.customPayloadModule = moduleManager.getCustomPayloadModule();
        this.exploitPlayerManager = moduleManager.getExploitPlayerManager();
        this.notificationsModule = moduleManager.getNotificationsModule();
        this.packetsModule = moduleManager.getPacketsModule();
        this.itemsFixModule = moduleManager.getItemsFixModule();
    }

    @Override
    public void onPacketDecode(final EventWrapper event) {
        if (!event.isCancelled()) {
            final PacketWrapper packetWrapper = event.getPacket();
            final PacketType packetType = packetWrapper.getType();
            final Player player = event.getPlayer();

            if (packetType != PacketType.PacketPlayInKeepAlive) {
                final Logger logger = plugin.getLogger();

                if (player != null && player.isOnline()) {
                    final String playerName = player.getName();
                    final ExploitPlayer exploitPlayer = exploitPlayerManager.get(player.getUniqueId(), player);

                    if (exploitPlayer != null) {
                        final Map<String, String> strings = packetWrapper.getStrings();
                        final String packetName = packetWrapper.getName();

                        if (packetsModule.isEnabled()) {
                            final Map<String, Integer> integers = packetWrapper.getIntegers();
                            final Map<String, ItemStack> items = packetWrapper.getItems();
                            final InventoryView inventoryView = player.getOpenInventory();
                            final double windowClick = packetsModule.getWindowClick(),
                                    setCreativeSlot = packetsModule.getSetCreativeSlot(),
                                    dataVls = packetsModule.getDataVls();
                            final int dataBytes = packetsModule.getDataBytes(),
                                    dataBytesSigns = packetsModule.getDataBytesSign();

                            if (integers.containsKey("slot")) {
                                final Inventory topInventory = inventoryView.getTopInventory(),
                                        bottomInventory = inventoryView.getBottomInventory();
                                final int slot = integers.get("slot"), maxSlots;

                                if (bottomInventory.getType() == InventoryType.PLAYER
                                        && topInventory.getType() == InventoryType.CRAFTING) {
                                    maxSlots = inventoryView.countSlots() + 4;
                                } else {
                                    maxSlots = inventoryView.countSlots();
                                }

                                if (slot < 0 && slot != -999) {
                                    if (notificationsModule.isDebug()) {
                                        logger.info(playerName + " has a slot less than 0 (" + slot + ")");
                                    }

                                    event.setCancelled(true);
                                    return;
                                } else if (slot >= maxSlots) {
                                    if (notificationsModule.isDebug()) {
                                        logger.info(playerName + " exceeded max available slots (" + slot + "/"
                                                + maxSlots + ") on " + packetName + "! Added vls: " + windowClick);
                                    }

                                    event.setCancelled(true);
                                    exploitPlayer.addVls(plugin, event, player, packetsModule, windowClick);
                                    return;
                                }
                            }

                            if (setCreativeSlot > 0 && packetType == PacketType.PacketPlayInSetCreativeSlot) {
                                if (player.getGameMode() != GameMode.CREATIVE) {
                                    if (notificationsModule.isDebug()) {
                                        logger.info(playerName + " sent SET_CREATIVE_SLOT without CREATIVE! Added vls: "
                                                + setCreativeSlot);
                                    }

                                    event.setCancelled(true);
                                    exploitPlayer.addVls(plugin, event, player, packetsModule, setCreativeSlot);
                                    return;
                                } else if (itemsFixModule.isEnabled() && items.containsKey("b")) {
                                    final ItemStack itemStack = itemsFixModule.fixItem(items.get("b"));

                                    packetWrapper.write("b", itemStack);

                                    if (notificationsModule.isDebug()) {
                                        logger.info(playerName + " had a creative item fixed by ExploiFixer!");
                                    }
                                }
                            }

                            int packetSize = 0;

                            if (dataVls > 0) {
                                final Map<String, Object> objects = packetWrapper.getObjects();

                                if (!objects.isEmpty()) {
                                    final Collection<Object> objectsValues = objects.values();

                                    for (final Object object : objectsValues) {
                                        if (object instanceof ItemStack) {
                                            packetSize += checkItem((ItemStack) object, exploitPlayer, player);
                                        } else {
                                            packetSize += String.valueOf(object)
                                                    .getBytes(StandardCharsets.UTF_8).length;
                                        }
                                    }
                                }

                                if (dataBytes > 0 && packetSize > dataBytes) {
                                    if (notificationsModule.isDebug()) {
                                        logger.info("[" + packetName + "] Sent by " + playerName
                                                + " got cancelled because its " + packetSize + " bytes long!");
                                    }

                                    event.setCancelled(true);
                                    exploitPlayer.addVls(plugin, event, player, packetsModule, dataVls);
                                    return;
                                }

                                if (dataBytesSigns > 0 && packetType == PacketType.PacketPlayInUpdateSign
                                        && checkSign(strings.values().toArray(new String[0]))) {
                                    if (notificationsModule.isDebug()) {
                                        logger.info(player.getName() + " has sent a too big sign packet! Added vls: "
                                                + dataVls);
                                    }

                                    event.setCancelled(true);
                                    exploitPlayer.addVls(plugin, event, player, packetsModule, dataVls);
                                    return;
                                }
                            }

                            final double bytesDividerAddition = packetSize / packetsModule.getDataBytesDivider();

                            exploitPlayer.addVls(plugin, event, player, packetsModule,
                                    packetsModule.getMultiplier(packetName) + bytesDividerAddition);
                        }

                        if (customPayloadModule.isEnabled() && packetType == PacketType.PacketPlayInCustomPayload) {
                            if (!strings.isEmpty()) {
                                final String tag = strings.values().iterator().next();
                                final double tagVls = customPayloadModule.getTagVls(),
                                        bookVls = customPayloadModule.getBookVls();

                                if (tagVls > 0 && tag == null || tag.isEmpty()) {
                                    if (notificationsModule.isDebug()) {
                                        logger.info(
                                                playerName + " sent CUSTOM_PAYLOAD without TAG! Added vls: " + tagVls);
                                    }

                                    event.setCancelled(true);
                                    exploitPlayer.addVls(plugin, event, player, customPayloadModule, tagVls);
                                    return;
                                } else {
                                    if (tag.equals("MC|BEdit") || tag.equals("MC|BSign") || tag.equals("MC|BOpen")) {
                                        final PlayerInventory playerInventory = player.getInventory();
                                        final ItemStack itemInHand = playerInventory
                                                .getItem(playerInventory.getHeldItemSlot());

                                        if (itemInHand != null && !itemInHand.getType().toString().contains("BOOK")) {
                                            if (notificationsModule.isDebug()) {
                                                logger.info(player.getName() + " tried to send a " + tag
                                                        + " custompayload packet without a book in hand!");
                                            }

                                            event.setCancelled(true);
                                            exploitPlayer.addVls(plugin, event, player, customPayloadModule, bookVls);
                                            return;
                                        } /*
                                           * else if (byteLength > customPayloadModule.getBookBytes()) {
                                           * logger.info(playerName + " tried to send a " + tag +
                                           * " custompayload packet without a book in hand!"); event.setCancelled(true);
                                           * exploitPlayer.addVls(plugin, event, player, customPayloadModule,
                                           * customPayloadModule.getBookVls()); return; } // WORK IN PROGRESS
                                           */
                                    }

                                    exploitPlayer.addVls(plugin, event, player, customPayloadModule,
                                            customPayloadModule.getMultiplier(tag));
                                }
                            } else {
                                if (notificationsModule.isDebug()) {
                                    logger.info(playerName + " sent a empty CustomPayload packet!");
                                }

                                event.setCancelled(true);
                            }
                        }
                    } else if (packetsModule.isOffline()) {
                        if (notificationsModule.isDebug()) {
                            logger.info(playerName + " sent a packet while offline!");
                        }

                        event.setCancelled(true);
                        event.abort();
                    }
                } else if (packetsModule.isOffline()) {
                    if (notificationsModule.isDebug()) {
                        logger.info("OFFLINEPLAYER sent a packet while offline!");
                    }

                    event.setCancelled(true);
                    event.abort();
                }
            }
        }
    }

    private int checkItem(final ItemStack itemStack, final ExploitPlayer exploitPlayer, final Player player) {
        final Logger logger = plugin.getLogger();
        int itemBytesLength = 0;

        if (itemStack != null) {
            final ItemMeta itemMeta = itemStack.getItemMeta();

            try {
                itemBytesLength += itemStack.getData().toString().getBytes(StandardCharsets.UTF_8).length;
            } catch (final Exception exception) {
                if (notificationsModule.isDebug()) {
                    logger.info("There was an exception when processing itemStack data to String!");
                }
            }

            if (itemStack.hasItemMeta() && itemMeta != null) {
                try {
                    if (itemMeta instanceof BlockStateMeta) {
                        final BlockStateMeta blockStateMeta = (BlockStateMeta) itemMeta;

                        if (blockStateMeta.hasBlockState()) {
                            final BlockState blockState = blockStateMeta.getBlockState();

                            if (blockState instanceof InventoryHolder) {
                                final InventoryHolder inventoryHolder = (InventoryHolder) blockState;

                                for (final ItemStack itemStack1 : inventoryHolder.getInventory().getContents()) {
                                    itemBytesLength += checkItem(itemStack1, exploitPlayer, player);
                                }
                            }
                        }
                    } else {
                        throw new Exception();
                    }
                } catch (final Exception exception) {
                    if (itemMeta instanceof BookMeta) {
                        itemBytesLength += checkBook(exploitPlayer, player, itemMeta);
                    } else {
                        try {
                            itemBytesLength += itemMeta.toString().getBytes(StandardCharsets.UTF_8).length;
                        } catch (final NullPointerException e) {
                            itemBytesLength += (itemMeta.getClass().getName() + "@"
                                    + Integer.toHexString(itemMeta.hashCode())).getBytes(StandardCharsets.UTF_8).length;
                        }
                    }
                }
            }
        }

        return itemBytesLength;
    }

    private int checkBook(final ExploitPlayer exploitPlayer, final Player player, final ItemMeta itemMeta) {
        final Logger logger = plugin.getLogger();
        final BookMeta bookMeta = (BookMeta) itemMeta;
        final double dataVls = packetsModule.getDataVls();
        final int pageCount = bookMeta.getPageCount(), dataBytesBook = packetsModule.getDataBytesBook();
        int bookTotalBytes = 0;

        if (pageCount > 50) {
            if (notificationsModule.isDebug()) {
                logger.info(player.getName() + " has sent a packet with a book with too many pages! (" + pageCount + "/"
                        + 50 + ") Added vls: " + dataVls);
            }

            exploitPlayer.addVls(plugin, null, player, packetsModule, dataVls);
        } else {
            for (final String page : bookMeta.getPages()) {
                final int pageBytes = page.getBytes(StandardCharsets.UTF_8).length;

                bookTotalBytes += pageBytes;

                if (pageBytes > dataBytesBook) {
                    if (notificationsModule.isDebug()) {
                        logger.info(
                                player.getName() + " has sent a packet with a book with too many characters per page! ("
                                        + pageBytes + "/" + dataBytesBook + ") Added vls: " + dataVls);
                    }

                    exploitPlayer.addVls(plugin, null, player, packetsModule, dataVls);
                    break;
                }
            }

            return bookTotalBytes;
        }

        return itemMeta.toString().getBytes(StandardCharsets.UTF_8).length;
    }

    private boolean checkSign(final String[] linesString) {
        final int dataBytesSign = packetsModule.getDataBytesSign();

        if (linesString != null) {
            if (linesString.length > 4) {
                return true;
            } else {
                for (final String line : linesString) {
                    if (line.getBytes(StandardCharsets.UTF_8).length > dataBytesSign) {
                        return true;
                    }
                }
            }
        }

        return false;
    }
}